<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试</title>
      <link href="/2022/01/23/%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/01/23/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/23/hello-world/"/>
      <url>/2022/01/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis其他功能</title>
      <link href="/2022/01/20/Redis%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/01/20/Redis%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Redis发布订阅"><a href="#一、Redis发布订阅" class="headerlink" title="一、Redis发布订阅"></a>一、Redis发布订阅</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><span id="more"></span><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/pubsub1.png" alt="img"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/pubsub2.png" alt="img"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">订阅频道:</span></span><br><span class="line"><span class="string">SUBSCRIBE</span> <span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>]<span class="string">:</span> <span class="string">订阅给定的一个或多个频道的信息</span></span><br><span class="line"><span class="string">PUNSUBSCRIBE</span> [<span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>]]<span class="string">:</span> <span class="string">订阅一个或多个符合给定模式的频道</span></span><br><span class="line"></span><br><span class="line"><span class="string">发布频道:</span></span><br><span class="line"><span class="attr">PUBLISH channel message:</span> <span class="string">将信息发送到指定的频道</span></span><br><span class="line"></span><br><span class="line"><span class="string">退订频道:</span></span><br><span class="line"><span class="string">UNSUBSCRIBE</span> [<span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>]]<span class="string">:</span> <span class="string">指退订给定的频道。</span></span><br><span class="line"><span class="string">PUNSUBSCRIBE</span> [<span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>]]<span class="string">:</span> <span class="string">退订所有给定模式的频道。</span></span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>这一功能最明显的用法就是构建实时消息系统，比如普通的即时聊天，群聊等功能</p><ol><li>在一个博客网站中，有100个粉丝订阅了 你，当你发布新文章，就可以推送消息给粉丝们。</li><li>微信公众号模式</li></ol><p><strong>微博</strong>，每个用户的粉丝都是该用户的订阅者，当用户发完微博，所有粉丝都将收到他的动态;</p><p><strong>新闻</strong>，资讯站点通常有多个频道，每个频道就是一个主题，用户可以通过主题来做订阅(如RSS)，这样当新闻发布时，订阅者可以获得更新</p><p>简单的应用场景的话，以J户网站为例，当编辑更新了某推荐板块的内容后:</p><ol><li>CMS发布清除缓存的消息到channel (推送者推送消息)</li><li>门户网站的缓存系统通过channel收到清除缓存的消息(订阅者收到消息)，更新了推荐板块的缓存</li><li>还可以做集中配置中心管理，当配置信息发生更改后，订阅配置信息的节点都可以收到通知消息</li></ol></blockquote><h1 id="二、Redis事务"><a href="#二、Redis事务" class="headerlink" title="二、Redis事务"></a>二、Redis事务</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><blockquote><p>批量操作在发送 EXEC 命令前被放入队列缓存。</p><p>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</p><p>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p></blockquote><ol><li><strong>Redis会将一个事务中的所有命令序列化，然后按顺序执行</strong></li><li><strong>执行中不会被其他命令插入，不允许出现加塞行为</strong></li></ol><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DISCARD:</span> <span class="string">取消事务，放弃执行事务块内的所有命令。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">EXEC:</span> <span class="string">执行所有事务块内的命令。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">MULTI:</span> <span class="string">标记一个事务块的开始。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">UNWATCH:</span> <span class="string">取消</span> <span class="string">WATCH</span> <span class="string">命令对所有</span> <span class="string">key</span> <span class="string">的监视。</span></span><br><span class="line"></span><br><span class="line"><span class="string">WATCH</span> <span class="string">key</span> [<span class="string">key</span> <span class="string">...</span>]<span class="string">:</span> <span class="string">监视一个(或多个)</span> <span class="string">key</span> <span class="string">，如果在事务执行之前这个(或这些)</span> <span class="string">key</span> <span class="string">被其他命令所改动，那么事务将被打断。</span></span><br></pre></td></tr></table></figure><h2 id="示例1-MULTI-EXEC"><a href="#示例1-MULTI-EXEC" class="headerlink" title="示例1 MULTI EXEC"></a>示例1 MULTI EXEC</h2><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120195041562.png" alt="image-20220120195041562"></p><h2 id="示例2-取消事务"><a href="#示例2-取消事务" class="headerlink" title="示例2 取消事务"></a>示例2 取消事务</h2><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120195015021.png" alt="image-20220120195015021"></p><h2 id="示例3-事务的错误处理"><a href="#示例3-事务的错误处理" class="headerlink" title="示例3 事务的错误处理"></a>示例3 事务的错误处理</h2><p>如果执行的某个命令出错，只有报错的命令不会执行，其他命令仍然执行，没有回滚</p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120195413499.png" alt="image-20220120195413499"></p><h2 id="示例4-事务的错误处理"><a href="#示例4-事务的错误处理" class="headerlink" title="示例4 事务的错误处理"></a>示例4 事务的错误处理</h2><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120195806870.png" alt="image-20220120195806870"></p><h2 id="示例5-事务的WATCH"><a href="#示例5-事务的WATCH" class="headerlink" title="示例5 事务的WATCH"></a>示例5 事务的WATCH</h2><p><strong>未做隔离</strong></p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120200203406.png" alt="image-20220120200203406"></p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120200223014.png" alt="image-20220120200223014"></p><p><strong>通过watch做隔离</strong></p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120200559526.png" alt="image-20220120200559526"></p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120200608947.png" alt="image-20220120200608947"></p><h1 id="三、Redis数据淘汰策略"><a href="#三、Redis数据淘汰策略" class="headerlink" title="三、Redis数据淘汰策略"></a>三、Redis数据淘汰策略</h1><p>Redis官方给的警告，当内存不足时，Redis会根据配置的缓存策略淘汰部分keys，以保证写入成功。当无淘汰策略时或没有找到适合淘汰的key时，Redis直接返回out of memory错误。</p><blockquote><p><strong>redis提供的8种淘汰策略：</strong></p><ul><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。</li></ul></blockquote><h1 id="四、Redis持久化"><a href="#四、Redis持久化" class="headerlink" title="四、Redis持久化"></a>四、Redis持久化</h1><p>Redis 提供两种持久化机制 <code>RDB</code> 和 <code>AOF</code> 机制:</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a><code>RDB</code> 持久化</h2><p>是指用数据集快照的方式半持久化模式)记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><p><strong>优点：</strong></p><blockquote><ol><li><p>只有一个文件 dump.rdb ，方便持久化。</p></li><li><p>容灾性好，一个文件可以保存到安全的磁盘。</p></li><li><p>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能)</p></li><li><p>相对于数据集大时，比 AOF 的启动效率更高。</p></li></ol></blockquote><p><strong>缺点：</strong></p><blockquote><p>数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p></blockquote><h2 id="AOF-Append-only-file-持久化方式"><a href="#AOF-Append-only-file-持久化方式" class="headerlink" title="AOF=Append-only file 持久化方式"></a><code>AOF=Append-only file</code> 持久化方式</h2><p>是指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储，保存为 AOF 文件。</p><p><strong>优点：</strong></p><blockquote><ol><li><p>数据安全， AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。</p></li><li><p>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p></li><li><p>AOF 机制的 rewrite 模式。 AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall )</p></li></ol></blockquote><p><strong>缺点：</strong></p><blockquote><ol><li><p>AOF 文件比 RDB 文件大，且恢复速度慢。</p></li><li><p>数据集大的时候，比 RDB 启动效率低。</p></li></ol></blockquote><h2 id="持久化选择"><a href="#持久化选择" class="headerlink" title="持久化选择"></a>持久化选择</h2><blockquote><ol><li><p>不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。</p></li><li><p>也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢复速度更快; 第二， RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。 </p></li><li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p></li><li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。</p></li></ol></blockquote><h1 id="五、Redis缓存与数据库一致性"><a href="#五、Redis缓存与数据库一致性" class="headerlink" title="五、Redis缓存与数据库一致性"></a>五、Redis缓存与数据库一致性</h1><h2 id="实时同步"><a href="#实时同步" class="headerlink" title="实时同步"></a>实时同步</h2><blockquote><p>对强一致性要求较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存；更新缓存时，先更新数据库，再将缓存设置为过期（建议不要去更新缓存内容，直接设置缓存过期）<br>用到的注解：</p><ul><li>@Cacheable: 查询时使用，注意long类型需要转化为string类型，否则会抛异常</li><li>@CachePut:更新时使用，使用此注解，一定会从DB上查数据</li><li>@CacheEvict:删除时使用</li><li>@Caching:组合用法</li></ul></blockquote><h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><blockquote><p>对于并发程度较高的，可采用异步队列的方式同步，采用kafka等消息中间件处理消息生产和消费</p></blockquote><h2 id="使用阿里的同步工具"><a href="#使用阿里的同步工具" class="headerlink" title="使用阿里的同步工具"></a>使用阿里的同步工具</h2><blockquote><p>canal实现方式是模拟mysql slave和master的同步机制，监控DB bitlong的日志更新来触发缓存的更新，此种方法可以解放程序员双手，减少工作量，但在使用时有些局限性。</p><p><strong>关于mysql主从复制：</strong></p><ol><li>master将改变记录到二进制日志（binary log）中（这些记录即二进制日志事件，binary log events可以通过show binary events进行查看） </li><li>slave 将master的binary log events 拷贝到它的中继日志（relay log）</li><li>slave重做中继日志中的事件，将改变反映它自己的数据</li></ol><p><strong>canal的工作原理：</strong></p><ol><li>canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议</li><li>MySQL master收到dump请求，开始推送binary blog给slave(就是canal)</li><li>canal解析binary log对象（原始为byte 流）</li></ol></blockquote><h2 id="采用UDF自定义函数的方式"><a href="#采用UDF自定义函数的方式" class="headerlink" title="采用UDF自定义函数的方式"></a>采用UDF自定义函数的方式</h2><blockquote><p>面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是c/c++实现，学习成本高。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h2><p>缓存穿透就是指查询一个一定不存在的数据，由于缓存不命中的时候会去数据库中查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要去数据库查询，造成了缓存穿透。</p><p><strong>解决办法:</strong></p><blockquote><ol><li>不管数据实际上存不存在，我们都把这个数据缓存在缓存中，然后设定一个特定的值，业务中如果获取达到这个特定值，就错误放回</li><li>采用<strong>布隆过滤器</strong>（Bloom Filter），将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li></ol></blockquote><h2 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h2><p>当缓存大量失效的时候，引发大量数据库查询</p><p><strong>解决办法：</strong></p><blockquote><ol><li>大多数系统设计者考虑用<strong>加锁</strong>（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</li><li><strong>数据预热</strong>：直接写个缓存刷新页面，上线时手工操作下； 数据量不大，可以在项目启动的时候自动进行加载； 定时刷新缓存；</li></ol></blockquote><h2 id="热点key-缓存击穿"><a href="#热点key-缓存击穿" class="headerlink" title="热点key(缓存击穿)"></a>热点key(缓存击穿)</h2><p>热点Key：某个Key访问非常频繁，当Key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃</p><p><strong>解决办法：</strong></p><blockquote><ol><li>使用同步方式锁，单机用synchronized,lock可重入锁等，分布式则用redis的setnx</li><li>采用缓存物理不过期，逻辑过期方式，在key对应的value设置一个timeout字段。如果检测到存的时间超过过期时间则异步更新缓存</li><li>在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作</li><li>设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步的更新实际缓存</li></ol></blockquote><h2 id="缓存倾斜"><a href="#缓存倾斜" class="headerlink" title="缓存倾斜"></a>缓存倾斜</h2><p>又称热点key倾斜。我们的redis一般都是集群，然后每个key更具（一致性hash算法）会落到某个集群的主机上面，如果出现了搞热数据，比如像某某微博的热点新闻，他们的key是固定的，所以这个key一定是在某个服务器上的，这个时候，如果高并发的话，大量的请求会涌向集群中的某一台服务器上，而我们使用集群的目的就是要平分请求，现在大量的请求集中到某台服务器上导致了倾斜，甚至可能导致缓存服务器的崩溃。</p><p><strong>解决办法：</strong></p><blockquote><ol><li>将一些特别热点的key直接放在客户端进行存储，设置过期时间，过期后再从后台中查询</li><li>利用分片算法的特性，对key进行打散处理</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tips：big key ，即数据量大的 key ，由于其数据大小远大于其他key，导致经过分片之后，某个具体存储这个 big key 的实例内存使用量远大于其他实例，造成，内存不足，拖累整个集群的使用。big key 在不同业务上，通常体现为不同的数据，比如：</span><br><span class="line">1. 论坛中的大型持久盖楼活动；</span><br><span class="line">2. 聊天室系统中热门聊天室的消息列表；</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><blockquote><h2 id="如何发现-hot-key，big-key"><a href="#如何发现-hot-key，big-key" class="headerlink" title="如何发现 hot key，big key"></a>如何发现 hot key，big key</h2><p><strong>1. 事前-预判</strong></p><p>在业务开发阶段，就要对可能变成 hot key ，big key 的数据进行判断，提前处理，这需要的是对产品业务的理解，对运营节奏的把握，对数据设计的经验。</p><p><strong>2.事中-监控和自动处理</strong></p><p><strong>监控</strong></p><ol><li><p>在应用程序端，对每次请求 redis 的操作进行收集上报;不推荐，但是在运维资源缺少的场景下可以考虑。开发可以绕过运维搞定）</p></li><li><p>在proxy层，对每一个 redis 请求进行收集上报;（推荐，改动涉及少且好维护）</p></li><li><p>对 redis 实例使用monitor命令统计热点key（不推荐，高并发条件下会有造成redis 内存爆掉的隐患）</p></li><li><p>机器层面，Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。如果站在机器的角度，可以通过对机器上所有Redis端口的TCP数据包进行抓取完成热点key的统计（不推荐，公司每台机器上的基本组件已经很多了，别再添乱了）</p></li></ol><p><strong>自动处理</strong></p><ol><li>通过监控之后，程序可以获取 big key 和 hot key，再报警的同时，程序对 big key 和 hot key 进行自动处理。或者通知程序猿利用一定的工具进行定制化处理（在程序中对特定的key 执行前面提到的解决方案）</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令</title>
      <link href="/2022/01/19/Redis%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/01/19/Redis%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Redis命令"><a href="#一、Redis命令" class="headerlink" title="一、Redis命令"></a>一、Redis命令</h1><p><strong>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</strong></p><span id="more"></span><h2 id="1-1-常用命令key管理"><a href="#1-1-常用命令key管理" class="headerlink" title="1.1.常用命令key管理"></a>1.1.常用命令key管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">keys pattern //返回满足条件的所有键，可以模糊匹配 比如 keys abc* 是找所有abc开头的key</span><br><span class="line">exists key   //检查给定 key 是否存在，存在返回1，不存在返回0</span><br><span class="line">expire key second //为给定 key 设置过期时间，以秒计。</span><br><span class="line">del key //该命令用于在 key 存在时删除 key。</span><br><span class="line">ttl key //以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)，key不存在是返回-2，key没有设置剩余时间返回-1</span><br><span class="line">persist key //移除 key 的过期时间，key 将持久保持。</span><br><span class="line">pexpire key millisecond //设置 key 的过期时间以毫秒计。</span><br><span class="line"></span><br><span class="line">select dbindex //选择数据库 数据库为0-15（默认是16个数据库）</span><br><span class="line">move keyname dbindex //将当前数据库中的key移动到新的数据库</span><br><span class="line">randomkey //随机返回一个key</span><br><span class="line">rename keyname newname //对key进行改名</span><br><span class="line">dbsize //查看数据库key的数量</span><br><span class="line">info //查看数据库信息</span><br><span class="line">flushdb //清空当前数据库数据</span><br><span class="line">flushdb //清空所有数据库数据</span><br></pre></td></tr></table></figure><h2 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2.应用场景"></a>1.2.应用场景</h2><p><strong>expire key second</strong></p><ol><li>限时的优惠信息</li><li>网站数据缓存（对一些实时需要更新的数据，例如：积分排行榜）</li><li>手机验证码</li><li>限制网站访客访问评率</li></ol><h2 id="1-3-key的命名建议"><a href="#1-3-key的命名建议" class="headerlink" title="1.3.key的命名建议"></a>1.3.key的命名建议</h2><p><strong>redis单个key允许存入512M大小</strong></p><ol><li>key不要太长，尽量不要超过1024字节，键名越长越占资源，降低查找效率</li><li>key也不要太短，太短可读性太差</li><li>在一个项目里，key最好使用统一的命名模式，例如user:123:password</li><li>key的名称区分大小写</li></ol><h1 id="二、Redis数据类型"><a href="#二、Redis数据类型" class="headerlink" title="二、Redis数据类型"></a>二、Redis数据类型</h1><h2 id="1-1-String类型"><a href="#1-1-String类型" class="headerlink" title="1.1.String类型"></a>1.1.String类型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p></li><li><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p></li><li><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p></li></ol><h3 id="String命令"><a href="#String命令" class="headerlink" title="String命令"></a>String命令</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">赋值语法:</span></span><br><span class="line"><span class="attr">set key value:</span> <span class="string">设置指定</span> <span class="string">key</span> <span class="string">的值。(多次赋值会覆盖,无视类型)</span></span><br><span class="line"><span class="attr">setnx key value:</span> <span class="string">只有在</span> <span class="string">key</span> <span class="string">不存在时设置</span> <span class="string">key</span> <span class="string">的值。(如果不存在，赋值后返回1，如反之则不会赋值并返回0)</span></span><br><span class="line"><span class="attr">setex key seconds value:</span> <span class="string">将值</span> <span class="string">value</span> <span class="string">关联到</span> <span class="string">key</span> <span class="string">，并将</span> <span class="string">key</span> <span class="string">的过期时间设为</span> <span class="string">seconds</span> <span class="string">(以秒为单位)。</span></span><br><span class="line"><span class="attr">setrange key offset value:</span> <span class="string">用</span> <span class="string">value</span> <span class="string">参数覆写给定</span> <span class="string">key</span> <span class="string">所储存的字符串值，从偏移量</span> <span class="string">offset</span> <span class="string">开始。</span></span><br><span class="line"></span><br><span class="line"><span class="string">取值语法:</span></span><br><span class="line"><span class="attr">get key:</span> <span class="string">获取指定</span> <span class="string">key</span> <span class="string">的值。(如果不存在，返回nil，如果类型不是string，则报错)</span></span><br><span class="line"><span class="attr">getrange key start end:</span> <span class="string">返回</span> <span class="string">key</span> <span class="string">中字符串值的子字符</span></span><br><span class="line"><span class="attr">getset key value:</span> <span class="string">将给定</span> <span class="string">key</span> <span class="string">的值设为</span> <span class="string">value</span> <span class="string">，并返回</span> <span class="string">key</span> <span class="string">的旧值。(不存在返回nil)</span></span><br><span class="line"><span class="attr">getbit key offset:</span> <span class="string">对</span> <span class="string">key</span> <span class="string">所储存的字符串值，获取指定偏移量上的位(bit)。</span></span><br><span class="line"><span class="attr">strlen key:</span> <span class="string">返回</span> <span class="string">key</span> <span class="string">所储存的字符串值的长度。</span></span><br><span class="line"></span><br><span class="line"><span class="string">删值语法:</span></span><br><span class="line"><span class="attr">del key:</span> <span class="string">删除指定的key</span></span><br><span class="line"></span><br><span class="line"><span class="string">批量写:</span></span><br><span class="line"><span class="attr">mset k1 v1 k2 v2 ...:</span> <span class="string">一次性写多个值</span></span><br><span class="line"><span class="string">批量读:</span></span><br><span class="line"><span class="string">mget</span> <span class="string">k1</span> <span class="string">k2</span> <span class="string">k3</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="string">自增/自减:</span></span><br><span class="line"><span class="attr">incr key:</span> <span class="string">将</span> <span class="string">key</span> <span class="string">中储存的数字值增一。(若key不存在，会默认给key赋值0)</span></span><br><span class="line"><span class="attr">incrby key increment:</span> <span class="string">将</span> <span class="string">key</span> <span class="string">中储存的数字值增一。</span></span><br><span class="line"><span class="attr">decr key:</span> <span class="string">将</span> <span class="string">key</span> <span class="string">中储存的数字值减一。</span></span><br><span class="line"><span class="attr">decrby key increment:</span> <span class="string">key</span> <span class="string">所储存的值减去给定的减量值（decrement）</span> <span class="string">。</span></span><br><span class="line"></span><br><span class="line"><span class="string">字符串拼接:</span> </span><br><span class="line"><span class="attr">append key value:</span> <span class="string">如果</span> <span class="string">key</span> <span class="string">已经存在并且是一个字符串，</span> <span class="string">APPEND</span> <span class="string">命令将指定的</span> <span class="string">value</span> <span class="string">追加到该</span> <span class="string">key</span> <span class="string">原来值（value）的末尾。</span></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>String通常用户保存单个字符串或者json字符串数据</li><li>因为string是二进制安全的，所以可以把图片文件的内容作为字符串来存储</li><li>计数器(常规key-value缓存应用。常规计数：微博数，粉丝数)</li></ol><blockquote><p>Redis所有单个命令的执行都是原子性的，这与它的单线程机制有关；</p><p>Redis命令的原子性使得我们不用考虑并发问题，可以方便的利用原子性自增操作</p></blockquote><h2 id="1-2-Hash类型"><a href="#1-2-Hash类型" class="headerlink" title="1.2.Hash类型"></a>1.2.Hash类型</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><h3 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">赋值语法:</span></span><br><span class="line"><span class="attr">hset key field value:</span> <span class="string">将哈希表</span> <span class="string">key</span> <span class="string">中的字段</span> <span class="string">field</span> <span class="string">的值设为</span> <span class="string">value</span> <span class="string">。</span></span><br><span class="line"><span class="string">hmset</span> <span class="string">key</span> <span class="string">field1</span> <span class="string">value1</span> [<span class="string">field</span> <span class="string">value2</span>]<span class="string">:</span> <span class="string">同时将多个</span> <span class="string">field-value</span> <span class="string">(域-值)对设置到哈希表</span> <span class="string">key</span> <span class="string">中。</span></span><br><span class="line"></span><br><span class="line"><span class="string">取值语法:</span></span><br><span class="line"><span class="attr">hget key field value:</span> <span class="string">获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">hmget</span> <span class="string">key</span> <span class="string">field1</span> [<span class="string">field</span>]<span class="string">:</span> <span class="string">获取所有给定字段的值</span></span><br><span class="line"><span class="attr">hgetall key:</span> <span class="string">获取在哈希表中指定</span> <span class="string">key</span> <span class="string">的所有字段和值</span></span><br><span class="line"><span class="attr">hkeys key:</span> <span class="string">获取hash表中的所有字段</span></span><br><span class="line"><span class="attr">hlen key:</span> <span class="string">获取hash表中的字段总数</span></span><br><span class="line"></span><br><span class="line"><span class="string">删值语法:</span></span><br><span class="line"><span class="attr">del key:</span> <span class="string">删除整个key</span></span><br><span class="line"><span class="string">hdel</span> <span class="string">key</span> <span class="string">field1</span> [<span class="string">field2</span>]<span class="string">:</span> <span class="string">删除一个或多个哈希表字段</span></span><br><span class="line"></span><br><span class="line"><span class="string">其他语法:</span></span><br><span class="line"><span class="attr">hsetnx key field value:</span> <span class="string">只有在字段</span> <span class="string">field</span> <span class="string">不存在时，设置哈希表字段的值。</span></span><br><span class="line"><span class="attr">hincrby key field increment:</span> <span class="string">只有在字段</span> <span class="string">field</span> <span class="string">不存在时，设置哈希表字段的值。</span></span><br><span class="line"><span class="attr">hexists key field:</span> <span class="string">查看哈希表key中指定的field存不存在</span></span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>常用与存储一个对象/分布式session</li></ol><h2 id="1-3-List类型"><a href="#1-3-List类型" class="headerlink" title="1.3.List类型"></a>1.3.List类型</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><h3 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">赋值语法:</span></span><br><span class="line"><span class="string">lpush</span> <span class="string">key</span> <span class="string">value1</span> [<span class="string">value2</span>]<span class="string">:</span> <span class="string">将一个或多个值插入到列表头部(左侧添加)</span></span><br><span class="line"><span class="string">rpush</span> <span class="string">key</span> <span class="string">value1</span> [<span class="string">value2</span>]<span class="string">:</span> <span class="string">在列表中添加一个或多个值(右侧添加)</span></span><br><span class="line"><span class="attr">lpushx key value:</span> <span class="string">为已存在的列表添加值(左侧添加)</span></span><br><span class="line"><span class="attr">rpushx key value:</span> <span class="string">为已存在的列表添加值(右侧添加)</span></span><br><span class="line"></span><br><span class="line"><span class="string">取值语法:</span></span><br><span class="line"><span class="attr">llen key:</span> <span class="string">获取列表长度</span></span><br><span class="line"><span class="attr">lindex key index:</span> <span class="string">通过索引获取列表中的元素</span></span><br><span class="line"><span class="attr">lrange key start stopw:</span> <span class="string">获取列表指定范围内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">删值语法:</span></span><br><span class="line"><span class="string">lpop</span> <span class="string">key</span> <span class="string">(count):</span> <span class="string">移出并获取列表的第一个元素(count可选移除元素的数量)</span></span><br><span class="line"><span class="string">rpop</span> <span class="string">key</span> <span class="string">(count):</span> <span class="string">移除列表的最后一个元素，返回值为移除的元素</span></span><br><span class="line"><span class="string">blpop</span> <span class="string">key1</span> [<span class="string">key2</span>] <span class="attr">timeout:</span> <span class="string">移出并获取列表的第一个元素，</span> <span class="string">如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</span></span><br><span class="line"><span class="string">brpop</span> <span class="string">key1</span> [<span class="string">key2</span>] <span class="attr">timeout:</span> <span class="string">移出并获取列表的最后一个元素，</span> <span class="string">如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</span></span><br><span class="line"><span class="attr">ltrim key start stop:</span> <span class="string">对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span></span><br><span class="line"></span><br><span class="line"><span class="string">修改语法:</span></span><br><span class="line"><span class="attr">lset key index value:</span> <span class="string">通过索引值改变元素</span></span><br><span class="line"><span class="string">linsert</span> <span class="string">key</span> <span class="string">before|after</span> <span class="attr">pivot value:</span> <span class="string">在列表的元素前或者后插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="string">其他语法:</span></span><br><span class="line"><span class="attr">rpoplpush source destination:</span> <span class="string">在列表的元素前或者后插入元素</span></span><br></pre></td></tr></table></figure><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>对数据量大的集合进行数据删减</strong></li></ol><blockquote><p>列表数据显示、关注列表、粉丝列表、留言评价…做分页、热点新闻(top5)</p></blockquote><ol start="2"><li><strong>任务队列</strong></li></ol><blockquote><p>list通常用来实现一个消息队列，而且可以确保先后顺序，不要像mysql的order by</p></blockquote><h2 id="1-4-Set类型"><a href="#1-4-Set类型" class="headerlink" title="1.4.Set类型"></a>1.4.Set类型</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>集合对象的编码可以是 intset 或者 hashtable。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>集合中最大的成员数为 2<sup>32</sup>-1, 每个集合可存储40多亿个成员)。</p><h3 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">赋值语法:</span></span><br><span class="line"><span class="string">zadd</span> <span class="string">key</span> <span class="string">score1</span> <span class="string">member1</span> [<span class="string">score2</span> <span class="string">member2</span>]<span class="string">:</span> <span class="string">向有序集合添加一个或多个成员，或者更新已存在成员的分数</span></span><br><span class="line"></span><br><span class="line"><span class="string">取值语法:</span></span><br><span class="line"><span class="attr">scard key:</span> <span class="string">获取集合的成员数</span></span><br><span class="line"><span class="attr">smembers key:</span> <span class="string">返回集合中的所有成员</span></span><br><span class="line"><span class="attr">sismember key member:</span> <span class="string">判断</span> <span class="string">member</span> <span class="string">元素是否是集合</span> <span class="string">key</span> <span class="string">的成员(存在性判断)</span></span><br><span class="line"><span class="string">srandmember</span> <span class="string">key</span> [<span class="string">count</span>]<span class="string">:</span> <span class="string">返回集合中一个或多个随机数</span></span><br><span class="line"></span><br><span class="line"><span class="string">删值语法:</span></span><br><span class="line"><span class="string">srem</span> <span class="string">key</span> <span class="string">member1</span> [<span class="string">member2</span>]<span class="string">:</span> <span class="string">移除集合中一个或多个成员</span></span><br><span class="line"><span class="string">spop</span> <span class="string">key</span> [<span class="string">count</span>]<span class="string">:</span> <span class="string">移除并返回集合中的一个随机元素</span></span><br><span class="line"><span class="attr">smove source destination member:</span> <span class="string">将</span> <span class="string">member</span> <span class="string">元素从</span> <span class="string">source</span> <span class="string">集合移动到</span> <span class="string">destination</span> <span class="string">集合</span></span><br><span class="line"></span><br><span class="line"><span class="string">集合语法:</span></span><br><span class="line"><span class="string">交集:</span></span><br><span class="line"><span class="string">sinter</span> <span class="string">key1</span> [<span class="string">key2</span>]<span class="string">:</span> <span class="string">返回给定所有集合的交集</span></span><br><span class="line"><span class="string">sinterstore</span> <span class="string">destination</span> <span class="string">key1</span> [<span class="string">key2</span>]<span class="string">:</span> <span class="string">返回给定所有集合的交集并存储在</span> <span class="string">destination</span> <span class="string">中</span></span><br><span class="line"><span class="string">并集:</span></span><br><span class="line"><span class="string">sunion</span> <span class="string">key1</span> [<span class="string">key2</span>]<span class="string">:返回所有给定集合的并集</span></span><br><span class="line"><span class="string">sunionstore</span> <span class="string">destination</span> <span class="string">key1</span> [<span class="string">key2</span>]<span class="string">:</span> <span class="string">所有给定集合的并集存储在</span> <span class="string">destination</span> <span class="string">集合中</span></span><br><span class="line"><span class="string">差集:</span></span><br><span class="line"><span class="string">sdiff</span> <span class="string">key1</span> [<span class="string">key2</span>]<span class="string">:</span>  <span class="string">返回第一个集合与其他集合之间的差异。</span></span><br><span class="line"><span class="string">sdiffstore</span> <span class="string">destination</span> <span class="string">key1</span> [<span class="string">key2</span>]<span class="string">:</span> <span class="string">返回给定所有集合的差集并存储在</span> <span class="string">destination</span> <span class="string">中</span></span><br></pre></td></tr></table></figure><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>对与两个集合间的数据计算(交集，差集，并集)</p><blockquote><ol><li>利用集合操作，可以取不同兴趣圈子的交集，方便实现共同关注、共同喜好、二度好友等功能。</li><li>利用唯一性，可以统计访问网站的所有独立ip、存取当天的活跃用户列表</li></ol></blockquote><h2 id="1-5-Zset类型"><a href="#1-5-Zset类型" class="headerlink" title="1.5.Zset类型"></a>1.5.Zset类型</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2<sup>32</sup>-1, 每个集合可存储40多亿个成员)。</p><h3 id="Zset命令"><a href="#Zset命令" class="headerlink" title="Zset命令"></a>Zset命令</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">赋值语法:</span></span><br><span class="line"><span class="string">sadd</span> <span class="string">key</span> <span class="string">member1</span> [<span class="string">membee2</span>]<span class="string">:</span> <span class="string">向集合添加一个或多个成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">取值语法:</span></span><br><span class="line"><span class="attr">ZCARD key:</span> <span class="string">获取有序集合的成员数</span></span><br><span class="line"><span class="attr">ZCOUNT key min max:</span> <span class="string">计算在有序集合中指定区间分数的成员数</span></span><br><span class="line"><span class="attr">ZRANK key member:</span> <span class="string">返回有序集合中指定成员的索引</span></span><br><span class="line"><span class="string">ZRANGE</span> <span class="string">key</span> <span class="string">start</span> <span class="string">stop</span> [<span class="string">WITHSCORES</span>]<span class="string">:</span> <span class="string">通过索引区间返回有序集合指定区间内的成员</span></span><br><span class="line"><span class="string">ZRANGEBYSCORE</span> <span class="string">key</span> <span class="string">min</span> <span class="string">max</span> [<span class="string">WITHSCORES</span>] [<span class="string">LIMIT</span>]<span class="string">:</span> <span class="string">通过分数返回有序集合指定区间内的成员</span></span><br><span class="line"><span class="string">ZREVRANGE</span> <span class="string">key</span> <span class="string">start</span> <span class="string">stop</span> [<span class="string">WITHSCORES</span>]<span class="string">:</span> <span class="string">返回有序集中指定区间内的成员，通过索引，分数从高到低</span></span><br><span class="line"><span class="string">ZREVRANGEBYSCORE</span> <span class="string">key</span> <span class="string">max</span> <span class="string">min</span> [<span class="string">WITHSCORES</span>]<span class="string">:</span> <span class="string">返回有序集中指定分数区间内的成员，分数从高到低排序</span></span><br><span class="line"></span><br><span class="line"><span class="string">删值语法:</span></span><br><span class="line"><span class="string">ZREM</span> <span class="string">key</span> <span class="string">member</span> [<span class="string">member</span> <span class="string">...</span>]<span class="string">:</span> <span class="string">移除有序集合中的一个或多个成员</span></span><br><span class="line"><span class="attr">ZREMRANGEBYRANK key start stop:</span> <span class="string">移除有序集合中给定的排名区间的所有成员</span></span><br><span class="line"><span class="attr">ZREMRANGEBYSCORE key min max:</span> <span class="string">移除有序集合中给定的分数区间的所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="string">其他语法:</span></span><br><span class="line"><span class="attr">ZINCRBY key increment member:</span> <span class="string">有序集合中对指定成员的分数加上增量</span> <span class="string">increment</span></span><br></pre></td></tr></table></figure><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>排行榜</p><blockquote><ol><li>用时间戳存储时间，作为score存储，这样获取数据是就是直接按照时间排序好的</li><li>班级成绩</li><li>用于带权重的队列，比如score=1是重要，socre=2是普通，工作线可以按照score获取任务，重要的优先</li></ol></blockquote><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><blockquote><p> <strong>什么是基数?</strong></p><p> 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PFADD</span> <span class="string">key</span> <span class="string">element</span> [<span class="string">element</span> <span class="string">...</span>]<span class="string">:</span> <span class="string">添加指定元素到</span> <span class="string">HyperLogLog</span> <span class="string">中。</span></span><br><span class="line"><span class="string">PFCOUNT</span> <span class="string">key</span> [<span class="string">key</span> <span class="string">...</span>]<span class="string">:</span> <span class="string">返回给定</span> <span class="string">HyperLogLog</span> <span class="string">的基数估算值。</span></span><br><span class="line"><span class="string">PFMERGE</span> <span class="string">destkey</span> <span class="string">sourcekey</span> [<span class="string">sourcekey</span> <span class="string">...</span>]<span class="string">:</span> <span class="string">将多个</span> <span class="string">HyperLogLog</span> <span class="string">合并为一个</span> <span class="string">HyperLogLog</span></span><br></pre></td></tr></table></figure><h1 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h1><p>说明：</p><ul><li>基数不大，数据量不大就用不上，会有点大材小用浪费空间</li><li>有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么</li><li>和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多</li><li>一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数</li></ul><p>一般使用：</p><blockquote><p>统计注册 IP 数</p><p>统计每日访问 IP 数</p><p>统计页面实时 UV 数</p><p>统计在线用户数</p><p>统计用户每天搜索不同词条的个数</p></blockquote><h1 id="三、SpringBoot整合Jedis"><a href="#三、SpringBoot整合Jedis" class="headerlink" title="三、SpringBoot整合Jedis"></a>三、SpringBoot整合Jedis</h1><h2 id="引入jedis依赖"><a href="#引入jedis依赖" class="headerlink" title="引入jedis依赖"></a>引入jedis依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置yml"><a href="#配置yml" class="headerlink" title="配置yml"></a>配置yml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># redis数据库</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.123</span> <span class="comment"># IP地址</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># redis连接密码</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment"># redis端口号</span></span><br><span class="line">    <span class="attr">jedis:</span> <span class="comment"># jedis相关配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span> <span class="comment"># 最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span> <span class="comment"># 最大空闲数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">1</span> <span class="comment"># 最小空闲数</span></span><br></pre></td></tr></table></figure><h2 id="编写config"><a href="#编写config" class="headerlink" title="编写config"></a>编写config</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dataBase;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.max-active&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxActive;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxIdle;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.jedis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.Jedis连接池配置</span></span><br><span class="line"><span class="comment">     * 2.在jedis连接池中活动jedis连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPool <span class="title">jedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(maxActive);</span><br><span class="line">        poolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        poolConfig.setMinIdle(minIdle);</span><br><span class="line">        JedisPool jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, host, port, <span class="number">2000</span>, password, dataBase);</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h2><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>Jedis操作String类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis完成缓存功能(String 操作)</span></span><br><span class="line"><span class="comment"> * 1.判断Redis是否存在改key</span></span><br><span class="line"><span class="comment"> *  如果key存在，直接查询Redis</span></span><br><span class="line"><span class="comment"> *  如果key不存在，查询mysql数据库，将查询的结果存入Redis中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> year 年份 2021 2022</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String year)</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;message:&quot;</span> + year;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    <span class="keyword">if</span> (!jedis.exists(key)) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;==================查询mysql数据库==================&quot;</span>);</span><br><span class="line">        String result = year + <span class="string">&quot;是虎年&quot;</span>;</span><br><span class="line">        jedis.set(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;==================查询redis数据库==================&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> jedis.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一遍运行：</p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220119195319864.png" alt="image-20220119195319864"></p><p>第二编运行：</p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220119195415686.png" alt="image-20220119195415686"></p><p><strong>Jedis操作Hash类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis Hash操作</span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户的信息</span></span><br><span class="line"><span class="comment"> *   1.根据用户id生成Redis Key</span></span><br><span class="line"><span class="comment"> *   2.判断redis中是否存在改key</span></span><br><span class="line"><span class="comment"> *   3.如果key不存在，查询mysql，并存入redis</span></span><br><span class="line"><span class="comment"> *   4.如果key存在，直接查询redis返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    String key = <span class="string">&quot;user:&quot;</span> + id;</span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    <span class="keyword">if</span> (!jedis.exists(key)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==================查询mysql数据库==================&quot;</span>);</span><br><span class="line">        user.setId(id).setName(<span class="string">&quot;李四&quot;</span>).setRemark(<span class="string">&quot;爱打游戏&quot;</span>);</span><br><span class="line">        jedis.hset(key, <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&quot;id&quot;</span>, user.getId());</span><br><span class="line">            put(<span class="string">&quot;name&quot;</span>, user.getName());</span><br><span class="line">            put(<span class="string">&quot;remark&quot;</span>, user.getRemark());</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==================查询redis数据库==================&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; userMap = jedis.hgetAll(key);</span><br><span class="line">        user.setId(userMap.get(<span class="string">&quot;id&quot;</span>)).setName(userMap.get(<span class="string">&quot;name&quot;</span>)).setRemark(userMap.get(<span class="string">&quot;remark&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一遍运行：</p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220119201750948.png" alt="image-20220119201750948"></p><p>第二遍运行：</p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220119201825788.png" alt="image-20220119201825788"></p><h1 id="四、SpringBoot中使用lettuce"><a href="#四、SpringBoot中使用lettuce" class="headerlink" title="四、SpringBoot中使用lettuce"></a>四、SpringBoot中使用lettuce</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--</span> <span class="string">redis</span> <span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置yml-1"><a href="#配置yml-1" class="headerlink" title="配置yml"></a>配置yml</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># redis数据库</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.123</span> <span class="comment"># IP地址</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># redis连接密码</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment"># redis端口号</span></span><br></pre></td></tr></table></figure><h2 id="更换redisTemplate默认的序列化接口"><a href="#更换redisTemplate默认的序列化接口" class="headerlink" title="更换redisTemplate默认的序列化接口"></a>更换redisTemplate默认的序列化接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//默认的序列化是jdk的 需要更换</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对String类型设置</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setValueSerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对hash类型设置</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;user:name:&quot;</span> + id;</span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============查询redis=============&quot;</span>);</span><br><span class="line">        String result = (String) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============查询mysql=============&quot;</span>);</span><br><span class="line">        String result = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        redisTemplate.opsForValue().set(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220119223721873.png" alt="image-20220119223721873"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">//String key = &quot;user:&quot;+id;</span></span><br><span class="line">    <span class="comment">//HashOperations&lt;K, HK, HV&gt; K:user HK:id HV:User对象</span></span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.opsForHash().hasKey(<span class="string">&quot;user&quot;</span>, id)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============查询redis=============&quot;</span>);</span><br><span class="line">        user = (User) redisTemplate.opsForHash().get(<span class="string">&quot;user&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============查询mysql=============&quot;</span>);</span><br><span class="line">        user.setId(id).setName(<span class="string">&quot;李四&quot;</span>).setRemark(<span class="string">&quot;爱玩游戏&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;user&quot;</span>, id, user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220119225626093.png" alt="image-20220119225626093"></p><h1 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h1><h2 id="5-1-案例一"><a href="#5-1-案例一" class="headerlink" title="5.1.案例一"></a>5.1.案例一</h2><p><strong>需求描述：</strong></p><blockquote><p>用户在客户端输入手机号，点击发送后随机产生4位数字密码，有效期为60秒</p><p>输入验证码，点击验证，返回成功或者失败。</p><p>且每个IP地址在5分钟内只能验证3次。并给出相应信息提示。</p></blockquote><ol><li>后台Redis生成一个key，value：验证码4位数字 （过期时间60秒）</li><li>前端用户输入的验证码和后台生成的Redis对应key的验证码进行比较</li><li>相等则注册成功 不相等则验证码校验失败</li><li>防止攻击：redis key：ip地址，value：自增 ，将此ip存入lock_ip 不给验证码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneValidateController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机验证码过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PHONE_NUMBER_CODE_EXPIRE_SECONDS = <span class="number">60</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保护key的过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PHONE_PROTECT_CODE_EXPIRE_SECONDS = <span class="number">60</span> * <span class="number">5</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码保护模式ip锁定时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PHONE_CODE_IP_LOCK_EXPIRE_SECONDS = <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成四位数验证码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 验证码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">generatorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = (<span class="keyword">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取访客的ip地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 访客ip地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIP</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取验证码 请求</span></span><br><span class="line"><span class="comment">     * 根据用户输入的手机号生成对应KEY key=phone:code:手机号码</span></span><br><span class="line"><span class="comment">     * 如果key不存在 对key进行赋值,并设置国旗时间：60s</span></span><br><span class="line"><span class="comment">     * 如果key存在，提示：验证码还在有效期内</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneNumber 用户输入手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getValidateCode&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValidateCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phoneNumber&quot;)</span> String phoneNumber, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        String phoneCodeIpLockKey = <span class="string">&quot;phone:code:lock:&quot;</span> + <span class="keyword">this</span>.getIP(request);</span><br><span class="line">        String protectKey = <span class="string">&quot;phone:code:&quot;</span> + <span class="keyword">this</span>.getIP(request);</span><br><span class="line">        String key = <span class="string">&quot;phone:code:&quot;</span> + phoneNumber;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (jedis.exists(phoneCodeIpLockKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;恶意获取验证码，你已被限制访问&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 保护模式</span></span><br><span class="line"><span class="comment">         * 1.生成保护KEY key=phone:code:ip</span></span><br><span class="line"><span class="comment">         * 2.判断 保护key是否存在</span></span><br><span class="line"><span class="comment">         *      不存在，则生成一个自增的，并设置过期时间为5分钟</span></span><br><span class="line"><span class="comment">         *      存在，则自增</span></span><br><span class="line"><span class="comment">         * 3.判断保护key的值是否大于3</span></span><br><span class="line"><span class="comment">         *      如果大于 生成一个锁住的ipkey  phone:code:lock:ip 过期时间为12小时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!jedis.exists(protectKey)) &#123;</span><br><span class="line">            jedis.incr(protectKey);</span><br><span class="line">            jedis.expire(protectKey, PHONE_PROTECT_CODE_EXPIRE_SECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jedis.incr(protectKey + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(jedis.get(protectKey)) &gt; <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">            jedis.set(phoneCodeIpLockKey, phoneCodeIpLockKey);</span><br><span class="line">            jedis.expire(phoneCodeIpLockKey, PHONE_CODE_IP_LOCK_EXPIRE_SECONDS);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;恶意获取验证码，限制访问&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!jedis.exists(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="keyword">this</span>.generatorCode();</span><br><span class="line">            log.info(<span class="string">&quot;手机号已发送API短信接口，验证码是：&quot;</span> + i);</span><br><span class="line">            jedis.set(key, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            jedis.expire(key, PHONE_NUMBER_CODE_EXPIRE_SECONDS);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;验证码发送成功，请查看手机短信&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Long timeNum = jedis.ttl(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;验证码获取失败，请耐心等待,剩余时间：&quot;</span> + timeNum + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将前端的用户输入的验证码信息与redis中验证</span></span><br><span class="line"><span class="comment">     * 相等：登录成功</span></span><br><span class="line"><span class="comment">     * 相等：验证码输入有误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code        用户输入的验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneNumber 用户输入的手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/validate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">validate</span><span class="params">(<span class="meta">@RequestParam(&quot;code&quot;)</span> String code, <span class="meta">@RequestParam(&quot;phoneNumber&quot;)</span> String phoneNumber)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        String key = <span class="string">&quot;phone:code:&quot;</span> + phoneNumber;</span><br><span class="line">        <span class="keyword">if</span> (code.equals(jedis.get(key))) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;手机号码校验成功，执行登录的相应业务逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// 清除当前key，节省内存空间</span></span><br><span class="line">            jedis.del(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;验证码校验成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;验证码校验失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-案例二"><a href="#5-2-案例二" class="headerlink" title="5.2.案例二"></a>5.2.案例二</h2><p><strong>需求描述：</strong></p><blockquote><p>用户在2分钟内，仅允许输入错误密码5次。</p><p>如果超过次数，限制其登录1小时。(要求每次登录失败时，给出相应提示)</p></blockquote><h2 id="5-3-案例三"><a href="#5-3-案例三" class="headerlink" title="5.3.案例三"></a>5.3.案例三</h2><p><strong>需求描述：</strong></p><blockquote><p>热点新闻列表</p><p>获取最新的5条首页新闻，获取最新的评论列表，获取最后登录10个用户，获取最近7天的活跃用户数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化五条新闻</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initNewsTop5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;news:top5&quot;</span>;</span><br><span class="line">    redisTemplate.opsForList().rightPush(key, <span class="string">&quot;1.讲好冬奥故事 共赴冰雪之约&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().rightPush(key, <span class="string">&quot;2.警方正在调查打工寻子案&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().rightPush(key, <span class="string">&quot;3.让正史成为全党全社会的共识热&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().rightPush(key, <span class="string">&quot;4.31省区市新增43例本土确诊热&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().rightPush(key, <span class="string">&quot;5.北京新增3例本土确诊病例&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最新的五条新闻</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getListTop5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;news:top5&quot;</span>;</span><br><span class="line">    List&lt;String&gt; newsList = (List&lt;String&gt;) (List) redisTemplate.opsForList().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> newsList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一条最新的新闻</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> news 新闻</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">addNewsTop</span><span class="params">(String news)</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;news:top5&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForList().leftPush(key, news);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120162635422.png" alt="image-20220120162635422"></p><h2 id="5-4-案例四"><a href="#5-4-案例四" class="headerlink" title="5.4.案例四"></a>5.4.案例四</h2><p><strong>需求描述：</strong></p><blockquote><p>任务队列(商城)</p><p>1.用户系统登录注册短信实名认证等</p><p>2.订单系统的下单流程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成订单物流队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cardId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initLogisticsQueue</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">    String executeKey = <span class="string">&quot;order:logistics:queue:execute:&quot;</span> + cardId;</span><br><span class="line">    redisTemplate.opsForList().leftPush(executeKey, <span class="string">&quot;1.商家发货&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPush(executeKey, <span class="string">&quot;2.北京====&gt;上海&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPush(executeKey, <span class="string">&quot;3.上海====&gt;浙江&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPush(executeKey, <span class="string">&quot;4.浙江====&gt;柯桥&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPush(executeKey, <span class="string">&quot;5.柯桥====&gt;夏履&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPush(executeKey, <span class="string">&quot;6.已签收&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cardId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">touchQueue</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">    String executeKey = <span class="string">&quot;order:logistics:queue:execute:&quot;</span> + cardId;</span><br><span class="line">    String successKey = <span class="string">&quot;order:logistics:queue:success:&quot;</span> + cardId;</span><br><span class="line">    <span class="keyword">return</span> (String) redisTemplate.opsForList().rightPopAndLeftPush(executeKey, successKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询已完成物流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cardId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">queryQueryExecute</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">    String executeKey = <span class="string">&quot;order:logistics:queue:execute:&quot;</span> + cardId;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;String&gt;) (List) redisTemplate.opsForList().range(executeKey, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询未完成物流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cardId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">queryQuerySuccess</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">    String successKey = <span class="string">&quot;order:logistics:queue:success:&quot;</span> + cardId;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;String&gt;) (List) redisTemplate.opsForList().range(successKey, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220120165332382.png" alt="image-20220120165332382"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简介</title>
      <link href="/2022/01/19/Redis%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/01/19/Redis%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h1><h2 id="1-1-Redis简介"><a href="#1-1-Redis简介" class="headerlink" title="1.1.Redis简介"></a>1.1.Redis简介</h2><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p><span id="more"></span><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h2 id="1-2-Redis-优势"><a href="#1-2-Redis-优势" class="headerlink" title="1.2.Redis 优势"></a>1.2.Redis 优势</h2><ul><li><strong>性能极高</strong> – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li><strong>丰富的数据类型</strong> – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li><strong>原子</strong> – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li><strong>丰富的特性</strong> – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li><li><strong>持久化</strong></li></ul><h2 id="1-3-Redis与其他key-value存储有什么不同？"><a href="#1-3-Redis与其他key-value存储有什么不同？" class="headerlink" title="1.3.Redis与其他key-value存储有什么不同？"></a>1.3.Redis与其他key-value存储有什么不同？</h2><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ul><h1 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h1><h2 id="2-1-安装前准备"><a href="#2-1-安装前准备" class="headerlink" title="2.1.安装前准备"></a>2.1.安装前准备</h2><h3 id="官网下载Redis"><a href="#官网下载Redis" class="headerlink" title="官网下载Redis"></a>官网下载<a href="https://redis.io/download">Redis</a></h3><h3 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc automake autoconf libtool make</span><br></pre></td></tr></table></figure><h2 id="2-2-安装Redis"><a href="#2-2-安装Redis" class="headerlink" title="2.2.安装Redis"></a>2.2.安装Redis</h2><h3 id="下载redis二进制文件"><a href="#下载redis二进制文件" class="headerlink" title="下载redis二进制文件"></a>下载redis二进制文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><h3 id="解压到-opt目录下"><a href="#解压到-opt目录下" class="headerlink" title="解压到/opt目录下"></a>解压到/opt目录下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz -C /opt</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/redis-6.2.6.tar.gz &amp;&amp; make MALLOC=libc</span><br></pre></td></tr></table></figure><h3 id="指定安装位置"><a href="#指定安装位置" class="headerlink" title="指定安装位置"></a>指定安装位置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure><h3 id="前往redis所在目录"><a href="#前往redis所在目录" class="headerlink" title="前往redis所在目录"></a>前往redis所在目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis</span><br></pre></td></tr></table></figure><h1 id="三、Redis启动"><a href="#三、Redis启动" class="headerlink" title="三、Redis启动"></a>三、Redis启动</h1><h2 id="3-1-服务端启动"><a href="#3-1-服务端启动" class="headerlink" title="3.1.服务端启动"></a>3.1.服务端启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server</span><br></pre></td></tr></table></figure><h2 id="3-2-客户端启动"><a href="#3-2-客户端启动" class="headerlink" title="3.2.客户端启动"></a>3.2.客户端启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-cli -h ip地址 -p 6379  //不填是ip地址默认是本机 端口号默认是6379</span><br></pre></td></tr></table></figure><h1 id="四、Redis配置"><a href="#四、Redis配置" class="headerlink" title="四、Redis配置"></a>四、Redis配置</h1><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 <strong>redis.conf</strong>(Windows 名为 redis.windows.conf)。</p><p>你可以通过 <strong>CONFIG</strong> 命令查看或设置配置项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure><h2 id="4-1-配置Redis"><a href="#4-1-配置Redis" class="headerlink" title="4.1.配置Redis"></a>4.1.配置Redis</h2><p>从reids的编译目录中复制一份redis.conf到安装目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/redis-6.2.6/redis.conf /usr/local/redis</span><br></pre></td></tr></table></figure><h2 id="4-2-redis-conf"><a href="#4-2-redis-conf" class="headerlink" title="4.2.redis.conf"></a>4.2.redis.conf</h2><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><table><thead><tr><th align="left">序号</th><th align="center">配置项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="center"><code>daemonize no</code></td><td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td align="left">2</td><td align="center"><code>pidfile /var/run/redis.pid</code></td><td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td align="left">3</td><td align="center"><code>port 6379</code></td><td align="left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td align="left">4</td><td align="center"><code>bind 127.0.0.1</code></td><td align="left">绑定的主机地址</td></tr><tr><td align="left">5</td><td align="center"><code>timeout 300</code></td><td align="left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td></tr><tr><td align="left">6</td><td align="center"><code>loglevel notice</code></td><td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td align="left">7</td><td align="center"><code>logfile stdout</code></td><td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td></tr><tr><td align="left">8</td><td align="center"><code>databases 16</code></td><td align="left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td align="left">9</td><td align="center"><code>save &lt;seconds&gt; &lt;changes&gt;</code></td><td align="left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td align="left">10</td><td align="center"><code>rdbcompression yes</code></td><td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td align="left">11</td><td align="center"><code>dbfilename dump.rdb</code></td><td align="left">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td align="left">12</td><td align="center"><code>dir ./</code></td><td align="left">指定本地数据库存放目录</td></tr><tr><td align="left">13</td><td align="center"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td><td align="left">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td align="left">14</td><td align="center"><code>masterauth &lt;master-password&gt;</code></td><td align="left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td></tr><tr><td align="left">15</td><td align="center"><code>requirepass foobared</code></td><td align="left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td></tr><tr><td align="left">16</td><td align="center"><code> maxclients 128</code></td><td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td align="left">17</td><td align="center"><code>maxmemory &lt;bytes&gt;</code></td><td align="left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td align="left">18</td><td align="center"><code>appendonly no</code></td><td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td align="left">19</td><td align="center"><code>appendfilename appendonly.aof</code></td><td align="left">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td align="left">20</td><td align="center"><code>appendfsync everysec</code></td><td align="left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td></tr><tr><td align="left">21</td><td align="center"><code>vm-enabled no</code></td><td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td align="left">22</td><td align="center"><code>vm-swap-file /tmp/redis.swap</code></td><td align="left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td></tr><tr><td align="left">23</td><td align="center"><code>vm-max-memory 0</code></td><td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td align="left">24</td><td align="center"><code>vm-page-size 32</code></td><td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td align="left">25</td><td align="center"><code>vm-pages 134217728</code></td><td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td align="left">26</td><td align="center"><code>vm-max-threads 4</code></td><td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td align="left">27</td><td align="center"><code>glueoutputbuf yes</code></td><td align="left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td align="left">28</td><td align="center"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td><td align="left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td></tr><tr><td align="left">29</td><td align="center"><code>activerehashing yes</code></td><td align="left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr><tr><td align="left">30</td><td align="center"><code>include /path/to/local.conf</code></td><td align="left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table><h3 id="Redis内存维护策略"><a href="#Redis内存维护策略" class="headerlink" title="Redis内存维护策略"></a>Redis内存维护策略</h3><p>Redis作为优秀的缓存中间件，而且是基于内存的，会存储大量的数据，即使采用了集群来扩容，也需要随时整理内存，防止内存溢出，保证性能。</p><p><strong>两种解决方法</strong>：</p><h4 id="一、为数据设置超时时间"><a href="#一、为数据设置超时时间" class="headerlink" title="一、为数据设置超时时间"></a>一、为数据设置超时时间</h4><blockquote><p>设置过期时间：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire key <span class="type">time</span>(以秒为单位)<span class="comment">--这是最常用的方式</span></span><br><span class="line">setex(String key,<span class="type">int</span> seconds, String <span class="keyword">value</span>)<span class="comment">--字符串独有的方式</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间</li><li>如果没有设置时间，那缓存就是永不过期</li><li>如果设置了过期时间，之后又想让缓存永不过期，使用<strong>persist key</strong></li></ul></blockquote><h4 id="二、采用LRU算法动态将不用的数据删除"><a href="#二、采用LRU算法动态将不用的数据删除" class="headerlink" title="二、采用LRU算法动态将不用的数据删除"></a>二、采用LRU算法动态将不用的数据删除</h4><blockquote><p>内存管理的一种页面置换算法，对于内存中但又不用的数据块（内存块）叫做LRU</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/image-20220119152116914.png" alt="image-20220119152116914"></p><h2 id="4-3-自定义配置Redis"><a href="#4-3-自定义配置Redis" class="headerlink" title="4.3.自定义配置Redis"></a>4.3.自定义配置Redis</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">daemonize no         //修改为daemonize yes 守护进程启动</span><br><span class="line">bind 127.0.0.1       //注释掉 允许除本机以外的机器访问Redis服务</span><br><span class="line">requirepass 你的密码   //设定数据库密码</span><br></pre></td></tr></table></figure><h1 id="五、Redis启动与关闭"><a href="#五、Redis启动与关闭" class="headerlink" title="五、Redis启动与关闭"></a>五、Redis启动与关闭</h1><h2 id="5-1-启动"><a href="#5-1-启动" class="headerlink" title="5.1.启动"></a>5.1.启动</h2><p>指定配置文件启动redis-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./bin/redis.conf</span><br></pre></td></tr></table></figure><p>输入密码启动redis-cli</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-cli -a 你的密码</span><br></pre></td></tr></table></figure><h2 id="5-2-关闭"><a href="#5-2-关闭" class="headerlink" title="5.2.关闭"></a>5.2.关闭</h2><h3 id="5-2-1-非正常关闭"><a href="#5-2-1-非正常关闭" class="headerlink" title="5.2.1.非正常关闭"></a>5.2.1.非正常关闭</h3><p><strong>直接断电或者kill</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure><h3 id="5-2-2-正常关闭"><a href="#5-2-2-正常关闭" class="headerlink" title="5.2.2.正常关闭"></a>5.2.2.正常关闭</h3><p><strong>使用reids-cli的shutdown关闭redis</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-cli -a 密码</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; shuotdown</span><br></pre></td></tr></table></figure><h1 id="六、远程连接"><a href="#六、远程连接" class="headerlink" title="六、远程连接"></a>六、远程连接</h1><h2 id="6-1-防火墙开放6379端口"><a href="#6-1-防火墙开放6379端口" class="headerlink" title="6.1.防火墙开放6379端口"></a>6.1.防火墙开放6379端口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><h2 id="6-2-可视化管理工具"><a href="#6-2-可视化管理工具" class="headerlink" title="6.2.可视化管理工具"></a>6.2.可视化管理工具</h2><ol><li>redis desktop manager  (收费 可用低版本)</li><li>Another Redis DeskTop Manage (免费)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署</title>
      <link href="/2022/01/18/hexo%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/01/18/hexo%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a>hexo博客搭建</h1><h2 id="1-安装node"><a href="#1-安装node" class="headerlink" title="1.安装node"></a>1.安装node</h2><blockquote><p>访问node官网下载node</p><p><a href="http://nodejs.cn/">Node.js 中文网 (nodejs.cn)</a></p></blockquote><span id="more"></span><h2 id="2-配置全局的淘宝node镜像"><a href="#2-配置全局的淘宝node镜像" class="headerlink" title="2.配置全局的淘宝node镜像"></a>2.配置全局的淘宝node镜像</h2><h3 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1.方法一"></a>2.1.方法一</h3><blockquote><p>配置cnpm</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="2-2-方法二"><a href="#2-2-方法二" class="headerlink" title="2.2.方法二"></a>2.2.方法二</h3><blockquote><p>配置全局的淘宝镜像</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry &quot;https://registry.npm.taobao.org&quot;</span><br></pre></td></tr></table></figure><h2 id="3-安装hexo-cli"><a href="#3-安装hexo-cli" class="headerlink" title="3.安装hexo-cli"></a>3.安装hexo-cli</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p>安装完成可以使用<code>hexo -v</code>查看是否安装成功</p></blockquote><h2 id="4-初始化博客"><a href="#4-初始化博客" class="headerlink" title="4.初始化博客"></a>4.初始化博客</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/imgimage-20220123122603641.png" alt="image-20220123122603641"></p><blockquote><p>使用<code>hexo s</code>查看能否启动</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/imgimage-20220123122631266.png" alt="image-20220123122631266"></p><p><img src="https://cdn.jsdelivr.net/gh/anjinran0/mypicgo/img/imgimage-20220123122650475.png" alt="image-20220123122650475"></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
